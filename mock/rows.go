// Autogenerated by the tool "go-mock-code-gen" built from
// gitlab.nolibox.com/skyteam/go-mock-code-gen
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

// mock 可以 mock 掉 Rows interface 的所有方法，方便编写单元测试。
package mock

import (
	"database/sql"
	"fmt"
	"sync"

	mysql "github.com/yangsai7/go-mysql"
)

type mockDataRows map[string][]interface{}
type mockDefaultDataRows map[string]interface{}

// MockDataAdderRows 用于向 MockRows 添加指定接口的测试数据。
// 这里添加的测试数据是一次性的，只要设置了的 mock 数据的接口被调用，数据就会按照 FIFO 顺序消费掉。
type MockDataAdderRows struct {
	m *MockRows
}

// MockFuncAdderRows 用于向 MockRows 添加指定接口的测试方法，当接口调用时这里设置的方法就会调用。
// 这里添加的测试数据是一次性的，只要设置了的 mock 数据的接口被调用，数据就会按照 FIFO 顺序消费掉。
type MockFuncAdderRows struct {
	m *MockRows
}

// MockDefaultDataRows 用于向 MockRows 添加指定接口的默认测试数据。
// 如果该接口没有设置测试数据或者测试数据已经消费完，这个默认的测试数据就会被返回给调用者。
// MockDefaultDataRows 和 MockDefaultFuncFuncRows 会互相覆盖。
// 如果设置了同一个接口的默认数据，会以最后调用为准。
type MockDefaultDataRows struct {
	m *MockRows
}

// MockDefaultFuncFuncRows 用于向 MockRows 添加指定接口的默认测试方法实现。
// 如果该接口没有设置测试数据或者测试数据已经消费完，这个默认的测试方法就会被调用。
// MockDefaultDataRows 和 MockDefaultFuncFuncRows 会互相覆盖。
// 如果设置了同一个接口的默认数据，会以最后调用为准。
type MockDefaultFuncRows struct {
	m *MockRows
}

// MockRows 是一个 mock 容器，可以将 Rows 接口的所有方法设置 mock 数据。
type MockRows struct {
	mu sync.Mutex

	data            mockDataRows
	defData         mockDefaultDataRows
	impl            mysql.Rows
	optionalMethods map[string]bool

	dataAdder   *MockDataAdderRows
	funcAdder   *MockFuncAdderRows
	defaultData *MockDefaultDataRows
	defaultFunc *MockDefaultFuncRows
}

type mockImplRows struct {
	mysql.Rows // 强行的实现 Rows 接口，用于做向后兼容。

	m *MockRows
}

// 确保 mockImplRows 始终实现了 mysql.Rows 接口。
var _ mysql.Rows = new(mockImplRows)

// NewRows 创建一个 Rows 的 mock 容器。
// impl 是一个默认的接口实现，假如接口没有被 mock 或者 mock 数据已经消费完，impl 的方法会被调用。
//
// impl 可以为 nil，但是这意味着没有默认实现，一旦调用一个没有 mock 数据的接口，且这个接口没有被设置为可选，那么会触发 panic。
func NewRows(impl mysql.Rows) *MockRows {
	optionalMethods := map[string]bool{}
	optionalMethods["Close"] = true
	optionalMethods["Init"] = true

	m := &MockRows{
		data:            mockDataRows{},
		defData:         mockDefaultDataRows{},
		impl:            impl,
		optionalMethods: optionalMethods,
	}
	m.dataAdder = &MockDataAdderRows{m}
	m.funcAdder = &MockFuncAdderRows{m}
	m.defaultData = &MockDefaultDataRows{m}
	m.defaultFunc = &MockDefaultFuncRows{m}
	return m
}

// Mock 返回一个实现了所有 Rows 方法的实例。
func (m *MockRows) Mock() mysql.Rows {
	return &mockImplRows{
		m: m,
	}
}

// DataAdder 返回一个添加接口测试数据的入口。
func (m *MockRows) DataAdder() *MockDataAdderRows {
	return m.dataAdder
}

// FuncAdder 返回一个添加接口回调的入口。
func (m *MockRows) FuncAdder() *MockFuncAdderRows {
	return m.funcAdder
}

// DefaultData 返回一个设置接口默认测试数据的入口。
func (m *MockRows) DefaultData() *MockDefaultDataRows {
	return m.defaultData
}

// DefaultFunc 返回一个设置接口默认回调的入口。
func (m *MockRows) DefaultFunc() *MockDefaultFuncRows {
	return m.defaultFunc
}

// Close 增加一个 Close 方法的返回值的 mock 数据。
// 如果 Rows#Close 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderRows) Close(err error) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "Close"
	__adder.m.data[__key] = append(__adder.m.data[__key], func() error {
		return err
	})
}

// Close 增加一个 mock 数据的回调函数，在执行 Rows#Close 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Rows#Close 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderRows) Close(f func() (err error)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "Close"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// Close 设置 Rows#Close 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().Close(...) 方法设置的默认回调。
func (__def *MockDefaultDataRows) Close(err error) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "Close"
	__def.m.defData[__key] = func() error {
		return err
	}
}

// Close 设置 Rows#Close 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().Close(...) 方法设置的默认数据。
func (def *MockDefaultFuncRows) Close(f func() (err error)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "Close"
	def.m.defData[key] = f
}

func (__impl *mockImplRows) Close() (err error) {
	__impl.m.mu.Lock()

	__key := "Close"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func() error)
			return __f()
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.Close()
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func() error)
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f()
}

// ColumnTypes 增加一个 ColumnTypes 方法的返回值的 mock 数据。
// 如果 Rows#ColumnTypes 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderRows) ColumnTypes(out0 []*sql.ColumnType, err error) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "ColumnTypes"
	__adder.m.data[__key] = append(__adder.m.data[__key], func() ([]*sql.ColumnType, error) {
		return out0, err
	})
}

// ColumnTypes 增加一个 mock 数据的回调函数，在执行 Rows#ColumnTypes 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Rows#ColumnTypes 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderRows) ColumnTypes(f func() (out0 []*sql.ColumnType, err error)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "ColumnTypes"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// ColumnTypes 设置 Rows#ColumnTypes 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().ColumnTypes(...) 方法设置的默认回调。
func (__def *MockDefaultDataRows) ColumnTypes(out0 []*sql.ColumnType, err error) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "ColumnTypes"
	__def.m.defData[__key] = func() ([]*sql.ColumnType, error) {
		return out0, err
	}
}

// ColumnTypes 设置 Rows#ColumnTypes 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().ColumnTypes(...) 方法设置的默认数据。
func (def *MockDefaultFuncRows) ColumnTypes(f func() (out0 []*sql.ColumnType, err error)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "ColumnTypes"
	def.m.defData[key] = f
}

func (__impl *mockImplRows) ColumnTypes() (out0 []*sql.ColumnType, err error) {
	__impl.m.mu.Lock()

	__key := "ColumnTypes"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func() ([]*sql.ColumnType, error))
			return __f()
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.ColumnTypes()
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func() ([]*sql.ColumnType, error))
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f()
}

// Columns 增加一个 Columns 方法的返回值的 mock 数据。
// 如果 Rows#Columns 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderRows) Columns(out0 []string, err error) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "Columns"
	__adder.m.data[__key] = append(__adder.m.data[__key], func() ([]string, error) {
		return out0, err
	})
}

// Columns 增加一个 mock 数据的回调函数，在执行 Rows#Columns 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Rows#Columns 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderRows) Columns(f func() (out0 []string, err error)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "Columns"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// Columns 设置 Rows#Columns 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().Columns(...) 方法设置的默认回调。
func (__def *MockDefaultDataRows) Columns(out0 []string, err error) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "Columns"
	__def.m.defData[__key] = func() ([]string, error) {
		return out0, err
	}
}

// Columns 设置 Rows#Columns 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().Columns(...) 方法设置的默认数据。
func (def *MockDefaultFuncRows) Columns(f func() (out0 []string, err error)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "Columns"
	def.m.defData[key] = f
}

func (__impl *mockImplRows) Columns() (out0 []string, err error) {
	__impl.m.mu.Lock()

	__key := "Columns"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func() ([]string, error))
			return __f()
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.Columns()
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func() ([]string, error))
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f()
}

// Err 增加一个 Err 方法的返回值的 mock 数据。
// 如果 Rows#Err 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderRows) Err(err error) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "Err"
	__adder.m.data[__key] = append(__adder.m.data[__key], func() error {
		return err
	})
}

// Err 增加一个 mock 数据的回调函数，在执行 Rows#Err 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Rows#Err 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderRows) Err(f func() (err error)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "Err"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// Err 设置 Rows#Err 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().Err(...) 方法设置的默认回调。
func (__def *MockDefaultDataRows) Err(err error) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "Err"
	__def.m.defData[__key] = func() error {
		return err
	}
}

// Err 设置 Rows#Err 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().Err(...) 方法设置的默认数据。
func (def *MockDefaultFuncRows) Err(f func() (err error)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "Err"
	def.m.defData[key] = f
}

func (__impl *mockImplRows) Err() (err error) {
	__impl.m.mu.Lock()

	__key := "Err"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func() error)
			return __f()
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.Err()
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func() error)
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f()
}

// Next 增加一个 Next 方法的返回值的 mock 数据。
// 如果 Rows#Next 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderRows) Next(out0 bool) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "Next"
	__adder.m.data[__key] = append(__adder.m.data[__key], func() bool {
		return out0
	})
}

// Next 增加一个 mock 数据的回调函数，在执行 Rows#Next 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Rows#Next 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderRows) Next(f func() (out0 bool)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "Next"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// Next 设置 Rows#Next 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().Next(...) 方法设置的默认回调。
func (__def *MockDefaultDataRows) Next(out0 bool) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "Next"
	__def.m.defData[__key] = func() bool {
		return out0
	}
}

// Next 设置 Rows#Next 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().Next(...) 方法设置的默认数据。
func (def *MockDefaultFuncRows) Next(f func() (out0 bool)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "Next"
	def.m.defData[key] = f
}

func (__impl *mockImplRows) Next() (out0 bool) {
	__impl.m.mu.Lock()

	__key := "Next"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func() bool)
			return __f()
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.Next()
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func() bool)
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f()
}

// NextResultSet 增加一个 NextResultSet 方法的返回值的 mock 数据。
// 如果 Rows#NextResultSet 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderRows) NextResultSet(out0 bool) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "NextResultSet"
	__adder.m.data[__key] = append(__adder.m.data[__key], func() bool {
		return out0
	})
}

// NextResultSet 增加一个 mock 数据的回调函数，在执行 Rows#NextResultSet 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Rows#NextResultSet 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderRows) NextResultSet(f func() (out0 bool)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "NextResultSet"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// NextResultSet 设置 Rows#NextResultSet 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().NextResultSet(...) 方法设置的默认回调。
func (__def *MockDefaultDataRows) NextResultSet(out0 bool) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "NextResultSet"
	__def.m.defData[__key] = func() bool {
		return out0
	}
}

// NextResultSet 设置 Rows#NextResultSet 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().NextResultSet(...) 方法设置的默认数据。
func (def *MockDefaultFuncRows) NextResultSet(f func() (out0 bool)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "NextResultSet"
	def.m.defData[key] = f
}

func (__impl *mockImplRows) NextResultSet() (out0 bool) {
	__impl.m.mu.Lock()

	__key := "NextResultSet"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func() bool)
			return __f()
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.NextResultSet()
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func() bool)
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f()
}

// Scan 增加一个 Scan 方法的返回值的 mock 数据。
// 如果 Rows#Scan 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderRows) Scan(err error) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "Scan"
	__adder.m.data[__key] = append(__adder.m.data[__key], func(dest ...interface{}) error {
		return err
	})
}

// Scan 增加一个 mock 数据的回调函数，在执行 Rows#Scan 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Rows#Scan 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderRows) Scan(f func(dest ...interface{}) (err error)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "Scan"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// Scan 设置 Rows#Scan 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().Scan(...) 方法设置的默认回调。
func (__def *MockDefaultDataRows) Scan(err error) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "Scan"
	__def.m.defData[__key] = func(dest ...interface{}) error {
		return err
	}
}

// Scan 设置 Rows#Scan 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().Scan(...) 方法设置的默认数据。
func (def *MockDefaultFuncRows) Scan(f func(dest ...interface{}) (err error)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "Scan"
	def.m.defData[key] = f
}

func (__impl *mockImplRows) Scan(dest ...interface{}) (err error) {
	__impl.m.mu.Lock()

	__key := "Scan"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func(dest ...interface{}) error)
			return __f(dest...)
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.Scan(dest...)
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func(dest ...interface{}) error)
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f(dest...)
}
