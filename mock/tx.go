// Autogenerated by the tool "go-mock-code-gen" built from
// gitlab.nolibox.com/skyteam/go-mock-code-gen
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

// mock 可以 mock 掉 Tx interface 的所有方法，方便编写单元测试。
package mock

import (
	"fmt"
	"sync"

	mysql "github.com/yangsai7/go-mysql"
)

type mockDataTx map[string][]interface{}
type mockDefaultDataTx map[string]interface{}

// MockDataAdderTx 用于向 MockTx 添加指定接口的测试数据。
// 这里添加的测试数据是一次性的，只要设置了的 mock 数据的接口被调用，数据就会按照 FIFO 顺序消费掉。
type MockDataAdderTx struct {
	m *MockTx
}

// MockFuncAdderTx 用于向 MockTx 添加指定接口的测试方法，当接口调用时这里设置的方法就会调用。
// 这里添加的测试数据是一次性的，只要设置了的 mock 数据的接口被调用，数据就会按照 FIFO 顺序消费掉。
type MockFuncAdderTx struct {
	m *MockTx
}

// MockDefaultDataTx 用于向 MockTx 添加指定接口的默认测试数据。
// 如果该接口没有设置测试数据或者测试数据已经消费完，这个默认的测试数据就会被返回给调用者。
// MockDefaultDataTx 和 MockDefaultFuncFuncTx 会互相覆盖。
// 如果设置了同一个接口的默认数据，会以最后调用为准。
type MockDefaultDataTx struct {
	m *MockTx
}

// MockDefaultFuncFuncTx 用于向 MockTx 添加指定接口的默认测试方法实现。
// 如果该接口没有设置测试数据或者测试数据已经消费完，这个默认的测试方法就会被调用。
// MockDefaultDataTx 和 MockDefaultFuncFuncTx 会互相覆盖。
// 如果设置了同一个接口的默认数据，会以最后调用为准。
type MockDefaultFuncTx struct {
	m *MockTx
}

// MockTx 是一个 mock 容器，可以将 Tx 接口的所有方法设置 mock 数据。
type MockTx struct {
	mu sync.Mutex

	data            mockDataTx
	defData         mockDefaultDataTx
	impl            mysql.Tx
	optionalMethods map[string]bool

	dataAdder   *MockDataAdderTx
	funcAdder   *MockFuncAdderTx
	defaultData *MockDefaultDataTx
	defaultFunc *MockDefaultFuncTx
}

type mockImplTx struct {
	mysql.Tx // 强行的实现 Tx 接口，用于做向后兼容。

	m *MockTx
}

// 确保 mockImplTx 始终实现了 mysql.Tx 接口。
var _ mysql.Tx = new(mockImplTx)

// NewTx 创建一个 Tx 的 mock 容器。
// impl 是一个默认的接口实现，假如接口没有被 mock 或者 mock 数据已经消费完，impl 的方法会被调用。
//
// impl 可以为 nil，但是这意味着没有默认实现，一旦调用一个没有 mock 数据的接口，且这个接口没有被设置为可选，那么会触发 panic。
func NewTx(impl mysql.Tx) *MockTx {
	optionalMethods := map[string]bool{}
	optionalMethods["Close"] = true
	optionalMethods["Init"] = true

	m := &MockTx{
		data:            mockDataTx{},
		defData:         mockDefaultDataTx{},
		impl:            impl,
		optionalMethods: optionalMethods,
	}
	m.dataAdder = &MockDataAdderTx{m}
	m.funcAdder = &MockFuncAdderTx{m}
	m.defaultData = &MockDefaultDataTx{m}
	m.defaultFunc = &MockDefaultFuncTx{m}
	return m
}

// Mock 返回一个实现了所有 Tx 方法的实例。
func (m *MockTx) Mock() mysql.Tx {
	return &mockImplTx{
		m: m,
	}
}

// DataAdder 返回一个添加接口测试数据的入口。
func (m *MockTx) DataAdder() *MockDataAdderTx {
	return m.dataAdder
}

// FuncAdder 返回一个添加接口回调的入口。
func (m *MockTx) FuncAdder() *MockFuncAdderTx {
	return m.funcAdder
}

// DefaultData 返回一个设置接口默认测试数据的入口。
func (m *MockTx) DefaultData() *MockDefaultDataTx {
	return m.defaultData
}

// DefaultFunc 返回一个设置接口默认回调的入口。
func (m *MockTx) DefaultFunc() *MockDefaultFuncTx {
	return m.defaultFunc
}

// Commit 增加一个 Commit 方法的返回值的 mock 数据。
// 如果 Tx#Commit 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderTx) Commit(err error) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "Commit"
	__adder.m.data[__key] = append(__adder.m.data[__key], func() error {
		return err
	})
}

// Commit 增加一个 mock 数据的回调函数，在执行 Tx#Commit 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Tx#Commit 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderTx) Commit(f func() (err error)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "Commit"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// Commit 设置 Tx#Commit 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().Commit(...) 方法设置的默认回调。
func (__def *MockDefaultDataTx) Commit(err error) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "Commit"
	__def.m.defData[__key] = func() error {
		return err
	}
}

// Commit 设置 Tx#Commit 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().Commit(...) 方法设置的默认数据。
func (def *MockDefaultFuncTx) Commit(f func() (err error)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "Commit"
	def.m.defData[key] = f
}

func (__impl *mockImplTx) Commit() (err error) {
	__impl.m.mu.Lock()

	__key := "Commit"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func() error)
			return __f()
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.Commit()
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func() error)
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f()
}

// Rollback 增加一个 Rollback 方法的返回值的 mock 数据。
// 如果 Tx#Rollback 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderTx) Rollback(err error) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "Rollback"
	__adder.m.data[__key] = append(__adder.m.data[__key], func() error {
		return err
	})
}

// Rollback 增加一个 mock 数据的回调函数，在执行 Tx#Rollback 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Tx#Rollback 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderTx) Rollback(f func() (err error)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "Rollback"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// Rollback 设置 Tx#Rollback 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().Rollback(...) 方法设置的默认回调。
func (__def *MockDefaultDataTx) Rollback(err error) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "Rollback"
	__def.m.defData[__key] = func() error {
		return err
	}
}

// Rollback 设置 Tx#Rollback 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().Rollback(...) 方法设置的默认数据。
func (def *MockDefaultFuncTx) Rollback(f func() (err error)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "Rollback"
	def.m.defData[key] = f
}

func (__impl *mockImplTx) Rollback() (err error) {
	__impl.m.mu.Lock()

	__key := "Rollback"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func() error)
			return __f()
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.Rollback()
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func() error)
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f()
}

// Prepare 增加一个 Prepare 方法的返回值的 mock 数据。
// 如果 Tx#Prepare 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderTx) Prepare(out0 mysql.Stmt, err error) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "Prepare"
	__adder.m.data[__key] = append(__adder.m.data[__key], func(query string) (mysql.Stmt, error) {
		return out0, err
	})
}

// Prepare 增加一个 mock 数据的回调函数，在执行 Tx#Prepare 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Tx#Prepare 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderTx) Prepare(f func(query string) (out0 mysql.Stmt, err error)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "Prepare"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// Prepare 设置 Tx#Prepare 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().Prepare(...) 方法设置的默认回调。
func (__def *MockDefaultDataTx) Prepare(out0 mysql.Stmt, err error) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "Prepare"
	__def.m.defData[__key] = func(query string) (mysql.Stmt, error) {
		return out0, err
	}
}

// Prepare 设置 Tx#Prepare 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().Prepare(...) 方法设置的默认数据。
func (def *MockDefaultFuncTx) Prepare(f func(query string) (out0 mysql.Stmt, err error)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "Prepare"
	def.m.defData[key] = f
}

func (__impl *mockImplTx) Prepare(query string) (out0 mysql.Stmt, err error) {
	__impl.m.mu.Lock()

	__key := "Prepare"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func(query string) (mysql.Stmt, error))
			return __f(query)
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.Prepare(query)
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func(query string) (mysql.Stmt, error))
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f(query)
}

// Exec 增加一个 Exec 方法的返回值的 mock 数据。
// 如果 Tx#Exec 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderTx) Exec(out0 mysql.Result, err error) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "Exec"
	__adder.m.data[__key] = append(__adder.m.data[__key], func(query string, args ...interface{}) (mysql.Result, error) {
		return out0, err
	})
}

// Exec 增加一个 mock 数据的回调函数，在执行 Tx#Exec 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Tx#Exec 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderTx) Exec(f func(query string, args ...interface{}) (out0 mysql.Result, err error)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "Exec"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// Exec 设置 Tx#Exec 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().Exec(...) 方法设置的默认回调。
func (__def *MockDefaultDataTx) Exec(out0 mysql.Result, err error) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "Exec"
	__def.m.defData[__key] = func(query string, args ...interface{}) (mysql.Result, error) {
		return out0, err
	}
}

// Exec 设置 Tx#Exec 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().Exec(...) 方法设置的默认数据。
func (def *MockDefaultFuncTx) Exec(f func(query string, args ...interface{}) (out0 mysql.Result, err error)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "Exec"
	def.m.defData[key] = f
}

func (__impl *mockImplTx) Exec(query string, args ...interface{}) (out0 mysql.Result, err error) {
	__impl.m.mu.Lock()

	__key := "Exec"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func(query string, args ...interface{}) (mysql.Result, error))
			return __f(query, args...)
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.Exec(query, args...)
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func(query string, args ...interface{}) (mysql.Result, error))
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f(query, args...)
}

// Query 增加一个 Query 方法的返回值的 mock 数据。
// 如果 Tx#Query 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderTx) Query(out0 mysql.Rows, err error) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "Query"
	__adder.m.data[__key] = append(__adder.m.data[__key], func(query string, args ...interface{}) (mysql.Rows, error) {
		return out0, err
	})
}

// Query 增加一个 mock 数据的回调函数，在执行 Tx#Query 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Tx#Query 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderTx) Query(f func(query string, args ...interface{}) (out0 mysql.Rows, err error)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "Query"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// Query 设置 Tx#Query 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().Query(...) 方法设置的默认回调。
func (__def *MockDefaultDataTx) Query(out0 mysql.Rows, err error) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "Query"
	__def.m.defData[__key] = func(query string, args ...interface{}) (mysql.Rows, error) {
		return out0, err
	}
}

// Query 设置 Tx#Query 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().Query(...) 方法设置的默认数据。
func (def *MockDefaultFuncTx) Query(f func(query string, args ...interface{}) (out0 mysql.Rows, err error)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "Query"
	def.m.defData[key] = f
}

func (__impl *mockImplTx) Query(query string, args ...interface{}) (out0 mysql.Rows, err error) {
	__impl.m.mu.Lock()

	__key := "Query"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func(query string, args ...interface{}) (mysql.Rows, error))
			return __f(query, args...)
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.Query(query, args...)
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func(query string, args ...interface{}) (mysql.Rows, error))
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f(query, args...)
}

// QueryRow 增加一个 QueryRow 方法的返回值的 mock 数据。
// 如果 Tx#QueryRow 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderTx) QueryRow(out0 mysql.Row, err error) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "QueryRow"
	__adder.m.data[__key] = append(__adder.m.data[__key], func(query string, args ...interface{}) (mysql.Row, error) {
		return out0, err
	})
}

// QueryRow 增加一个 mock 数据的回调函数，在执行 Tx#QueryRow 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Tx#QueryRow 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderTx) QueryRow(f func(query string, args ...interface{}) (out0 mysql.Row, err error)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "QueryRow"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// QueryRow 设置 Tx#QueryRow 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().QueryRow(...) 方法设置的默认回调。
func (__def *MockDefaultDataTx) QueryRow(out0 mysql.Row, err error) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "QueryRow"
	__def.m.defData[__key] = func(query string, args ...interface{}) (mysql.Row, error) {
		return out0, err
	}
}

// QueryRow 设置 Tx#QueryRow 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().QueryRow(...) 方法设置的默认数据。
func (def *MockDefaultFuncTx) QueryRow(f func(query string, args ...interface{}) (out0 mysql.Row, err error)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "QueryRow"
	def.m.defData[key] = f
}

func (__impl *mockImplTx) QueryRow(query string, args ...interface{}) (out0 mysql.Row, err error) {
	__impl.m.mu.Lock()

	__key := "QueryRow"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func(query string, args ...interface{}) (mysql.Row, error))
			return __f(query, args...)
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.QueryRow(query, args...)
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func(query string, args ...interface{}) (mysql.Row, error))
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f(query, args...)
}

// Stmt 增加一个 Stmt 方法的返回值的 mock 数据。
// 如果 Tx#Stmt 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (__adder *MockDataAdderTx) Stmt(out0 mysql.Stmt, err error) {
	__adder.m.mu.Lock()
	defer __adder.m.mu.Unlock()

	__key := "Stmt"
	__adder.m.data[__key] = append(__adder.m.data[__key], func(stmt mysql.Stmt) (mysql.Stmt, error) {
		return out0, err
	})
}

// Stmt 增加一个 mock 数据的回调函数，在执行 Tx#Stmt 方法时会调用，并用这个回调函数的返回值来作为接口返回值。
// 如果 Tx#Stmt 被调用，这个 mock 数据就会按照 FIFO 顺序被消费掉。
func (adder *MockFuncAdderTx) Stmt(f func(stmt mysql.Stmt) (out0 mysql.Stmt, err error)) {
	adder.m.mu.Lock()
	defer adder.m.mu.Unlock()

	key := "Stmt"
	adder.m.data[key] = append(adder.m.data[key], f)
}

// Stmt 设置 Tx#Stmt 方法的默认 mock 数据，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultFunc().Stmt(...) 方法设置的默认回调。
func (__def *MockDefaultDataTx) Stmt(out0 mysql.Stmt, err error) {
	__def.m.mu.Lock()
	defer __def.m.mu.Unlock()

	__key := "Stmt"
	__def.m.defData[__key] = func(stmt mysql.Stmt) (mysql.Stmt, error) {
		return out0, err
	}
}

// Stmt 设置 Tx#Stmt 方法的默认回调函数，仅当所有 mock 数据消耗完之后起作用。
// 这个函数会覆盖 m.DefaultData().Stmt(...) 方法设置的默认数据。
func (def *MockDefaultFuncTx) Stmt(f func(stmt mysql.Stmt) (out0 mysql.Stmt, err error)) {
	def.m.mu.Lock()
	defer def.m.mu.Unlock()

	key := "Stmt"
	def.m.defData[key] = f
}

func (__impl *mockImplTx) Stmt(stmt mysql.Stmt) (out0 mysql.Stmt, err error) {
	__impl.m.mu.Lock()

	__key := "Stmt"
	__data := __impl.m.data[__key]

	if len(__data) == 0 {
		__defData, __ok := __impl.m.defData[__key]
		__impl.m.mu.Unlock()

		if __ok {
			__f := __defData.(func(stmt mysql.Stmt) (mysql.Stmt, error))
			return __f(stmt)
		}

		if __impl.m.impl != nil {
			return __impl.m.impl.Stmt(stmt)
		}

		if _, __ok := __impl.m.optionalMethods[__key]; __ok {
			return
		}

		panic(fmt.Sprintf("no mock data nor default implementation. [method:%v]", __key))
	}

	// FIFO 顺序。
	__f := __data[0].(func(stmt mysql.Stmt) (mysql.Stmt, error))
	__impl.m.data[__key] = __data[1:]
	__impl.m.mu.Unlock()

	return __f(stmt)
}
